
//the interface for the library. basically call this to twerk
var compile = function compile(program) {
	output = "";
	sensors = [];
	var filename = "code.js";
	if (!program) {
		throw new Error("no program input to compile!");
		return undefined;
	}

	//add header for include
	output += addHeader();

	//get START node
	var startNode = program.nodeDataArray.filter(function (obj) {
		return obj.text == "Start";
	})[0];

	//GO GO GADGET
	exec(program, getNext(program, startNode));

	//return correctly
	return {code: output, sensors: sensors};

}

//get the node connected to this one
//this needs a shitload of testing I guess
function getNext(program, node, where) {
	//if we don't care which path we take
	if (!where) {
		//get where are we going from the linkDataArray
		var toKey = program.linkDataArray.filter(function (obj) {
			return obj.from == node.key;
		})[0];
		//if we aren't going anywhere, there is no "next"
		if (!toKey) {
			return undefined;
		}
		toKey = toKey.to;
		//and return the node to which we are going
		return program.nodeDataArray.filter(function (obj) {
			return obj.key == toKey;
		})[0];
	//if we care where are we going and we got a regexp
	} else {
		var re = new RegExp(where, "g");
		var toKey = program.linkDataArray.filter(function (obj) {
			return ((obj.from == node.key) && (obj.fromPort.match(re)));
		})[0];
		if(!toKey) {
			return undefined;
		}
		toKey = toKey.to;
		return program.nodeDataArray.filter(function (obj) {
			return obj.key == toKey;
		})[0];
	}
}

//get and return condition nodes for the IF block
function getConditions(program, node) {
	var condNode = program.nodeDataArray.filter(function (obj) {
		return ((obj.isGroup == true) && (obj.text == "Conditions") && (obj.group == node.key));
	})[0];
	var conditions = program.nodeDataArray.filter(function (obj) {
		return (obj.group == condNode.key);
	});
	return conditions;
}

//black magic
//this function basically does everything
//maybe except for cooking bacon and pancakes
//TO DO: in version 1.2, enable bacon and pancake functionality
function exec(program, node) {
	//regexp to find the delay node
	var re = new RegExp("delay", "g");
	if (!node)
		return 0;
	//if branch
	if (node.text == "IF") {
		execIfNode(program, node);
	} else if (node.text.match(re)) {
		//tady bude neco
		execDelay(program, node);
	} else {
		//action!
		execAction(program, node);
	}

};

//parse an If node
function execIfNode(program, node) {
	output += "if (";
	//conditions
	var conditions = getConditions(program, node);
	if (conditions.length < 1) {
		return undefined
	} else {
		output += "library.condition(";
		output += "db, ";
		output += "[";
		for (var i = 0; i < conditions.length; i++) {
			output += "'" + conditions[i].key + "'";
			// , between arguments if this isn't the last one
			if (i != conditions.length-1)
				output += ", ";
			//add condition to list of sensors!
			sensors.push(conditions[i].key);
		};
		output += "]"
		output += ")";
	}
	output += ") {\n";
	//evaluate the YES branch
	// output += "console.log('TOOK YES BRANCH')\n";
	exec(program, getNext(program, node, "yes"));
	output += "}";
	//if we have a NO branch
	if (getNext(program, node, "no")) {
		output += " else {";
		// output += "console.log('TOOK NO BRANCH')\n";
		exec(program, getNext(program, node, "no"));
		output += "}";
	}
	output += "\n";
}

//parse an action node
function execAction(program, node) {
	output += "library.action(" + "'" + node.key + "'" + ");\n";
	exec(program, getNext(program, node));

}

//parse a delay node
function execDelay(program, node) {
	//timeout is a fixed value for now, ten of something(?)
	var timeout = 2000;
	output += "setTimeout(function() {\n";
	exec(program, getNext(program, node));
	output += "}, " + timeout + ");\n";
}



//add Header bullshit to the generated code
//includes, use strict, "original content do not steal" and similar stuff belongs here
function addHeader() {
	var output = "";
	output += "//THIS CODE WAS GENERATED BY BLACK MAGIC";
	output += "'use strict';";
	output += "var library = require('./../compiler/library');";
	return output;
}

module.exports = compile;
